<?xml version="1.0" encoding="UTF-8" ?><rss version="2.0"><channel><title>Help Wanted</title><description>Help Wanted Issues</description><link>https://lbonanomi.github.io/rss/feed.xml</link><item>	<title>Allow rendering collection of components</title>	<link>https://github.com/github/actionview-component/issues/114</link>	<description><![CDATA[When rendering jbuilder partials, the following can be used instead of explicitly writing a loop that renders each partial:<br/><br/>```ruby<br/>json.partial! \"posts/post\", collection: @posts, as: :post<br/>```<br/><br/>It would be interesting if we could have something similar for components. The example below assumes a PostComponent is defined.<br/><br/>```ruby<br/># posts_controller.rb<br/><br/>class PostsController < ApplicationController<br/>  def index<br/>    @posts = Post.scope_that_queries_the_right_posts(params)
<br/>  end<br/>end<br/><br/># app/views/posts/index.html.erb<br/><br/><%= render @posts %><br/>```<br/><br/>In this case, for each record we would get the associated component and render it. I'd love some feedback and implementations ideas. I can work on some implementation suggestions." ]]></description></item><item>	<title>Include test case class for components</title>	<link>https://github.com/github/actionview-component/issues/109</link>	<description><![CDATA[Here is what I'm currently using on my `test_helper.rb` file.<br/><br/>```ruby<br/>class ActionView::ComponentTest < ActiveSupport::TestCase<br/>  include ActionView::Component::TestHelpers<br/>end<br/>```<br/><br/>I think it's a good idea to provide this base for class for testing components." ]]></description></item><item>	<title>Compile components on application boot</title>	<link>https://github.com/github/actionview-component/issues/100</link>	<description><![CDATA[In production, it would probably make sense to `compile` all descendents of `ActionView::Component::Base`, so that components render quickly on the first request, instead of compiling lazily as they do now." ]]></description></item><item>	<title>Add benchmark script</title>	<link>https://github.com/github/actionview-component/issues/99</link>	<description><![CDATA[It would be great to have some form of integration-level benchmark script that we can use to make sure changes to this library are not slowing things down.<br/><br/>I've used https://github.com/evanphx/benchmark-ips in the past, but am open to other options as well." ]]></description></item><item>	<title>Remove initializer requirement for Ruby 2.7</title>	<link>https://github.com/github/actionview-component/issues/93</link>	<description><![CDATA[Per https://blog.saeloun.com/2019/09/17/ruby-2-7-module-const-source-location.html, we should be able to remove the requirement of having initializers in Ruby 2.7." ]]></description></item><item>	<title>Allow rendering components in the controller</title>	<link>https://github.com/github/actionview-component/issues/38</link>	<description><![CDATA[Hi @joelhawksley <br/><br/>I am happy to see a view model lib, that integrates smoothly with rails. While playing around with `ActionView::Component` i noticed that it is not possible to render components in the controller. I saw, that you are monkey patching `ActionView::Base#render`. So i tried to override the `render` method in my `ApplicationController` in a similar way, but without success.<br/><br/>At the moment users are forced to write templates with a single line: `<%= render(PostShowComponent, post: @post)
 %>`. It would be great to have an API like this:<br/><br/>```ruby <br/>class PostsController < ApplicationController<br/>  def show <br/>    post = Post.find(params[:id])
<br/>    render(PostShowComponent, post: post)
<br/>  end<br/>end<br/>```<br/>I could provide a PR with a failing feature test, if that helps. <br/><br/>Thank you , ushi<br/><br/>P.S. Found a workaround. Maybe its a good starting point:<br/><br/>```ruby<br/>class ApplicationController<br/>  private<br/><br/>  def render_component(component, args, **options)
<br/>    options = options.reverse_merge(layout: true)
<br/>    render(html: view_context.render(component, args)
, options)
<br/>  end <br/>end<br/>```<br/><br/>" ]]></description></item><item>	<title>Any tips for rendering Components from collections?</title>	<link>https://github.com/github/actionview-component/issues/21</link>	<description><![CDATA[Before I start playing around with this, I wanted to ask if there is a preferred way, best practice, or even a helper to render components for collections  <a href="https://guides.rubyonrails.org/layouts_and_rendering.html#rendering-collections">similar to the rails guide for partials</a> 

<br/><br/>I think this would be a common use case, and would be willing to submit a PR for a documentation example." ]]></description></item><item>	<title>Clojure(Script)
 support</title>	<link>https://github.com/github/semantic/issues/217</link>	<description><![CDATA[Any possibility of adding Clojure/ClojureScript support?" ]]></description></item><item>	<title>Self signed certificates</title>	<link>https://github.com/grafana/grafana-image-renderer/issues/33</link>	<description><![CDATA[I tested the render plugin against a Grafana instance with self signed certificate. I got the following error:<br/>Error: net::ERR_CERT_COMMON_NAME_INVALID<br/><br/>Would be nice with a config parameter to trust unsigned certificates as that's probably the issue." ]]></description></item><item>	<title>Color of diff changes when scrolling up and down</title>	<link>https://github.com/grafana/tanka/issues/82</link>	<description><![CDATA[Example: https://www.youtube.com/watch?v=1UKlgCK2EeM<br/>" ]]></description></item><item>	<title>Make tanka available as kubectl plugin</title>	<link>https://github.com/grafana/tanka/issues/45</link>	<description><![CDATA[Looking at this project, I think it should be possible to make this interface with the kubectl plugins and distribute via krew.<br/>https://github.com/kubernetes-sigs/krew<br/><br/>Let me know what you think! " ]]></description></item></channel></rss>
